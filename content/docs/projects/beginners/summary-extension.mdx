---
title: 文本摘要浏览器扩展
description: 构建一个可提取网页内容摘要的Chrome浏览器扩展
---

# 构建文本摘要浏览器扩展

在本教程中，我们将创建一个Chrome浏览器扩展，它可以分析当前网页内容，提取出关键信息并生成简明的摘要。这个项目将帮助你了解浏览器扩展的基本开发流程和内容脚本的使用。

```
![文本摘要扩展截图](/images/docs/projects/summary-extension-screenshot.png)
```

## 项目概述

**预计完成时间**: 3-4小时  
**难度等级**: ⭐⭐☆☆☆ (入门级+)  
**前置知识**: 基础HTML、CSS和JavaScript  
**项目目标**: 创建一个可以提取网页内容摘要的Chrome浏览器扩展

### 你将学到什么

- Chrome浏览器扩展的基本架构和开发流程
- 内容脚本(Content Scripts)的使用
- DOM操作和文本处理技术
- 浏览器API和消息传递机制
- 简单的自然语言处理技术

### 完成项目后的成果

一个功能完整的Chrome扩展，可以：
- 在任何网页上点击扩展图标，生成内容摘要
- 提取页面的主要文本内容
- 识别并展示页面上的重要信息
- 以简洁易读的方式显示结果
- 支持复制摘要内容到剪贴板

## 开发环境准备

这个项目需要以下工具：

1. 代码编辑器（推荐Visual Studio Code或Cursor）
2. Chrome浏览器
3. 基础的HTML/CSS/JavaScript知识

不需要安装任何外部库或框架。

## 项目结构

我们将创建以下文件结构：

```
summary-extension/
├── manifest.json         # 扩展配置文件
├── popup/
│   ├── popup.html        # 弹出窗口HTML
│   ├── popup.css         # 弹出窗口样式
│   └── popup.js          # 弹出窗口脚本
├── scripts/
│   ├── content.js        # 内容脚本(与页面交互)
│   └── summarizer.js     # 文本摘要生成逻辑
└── images/
    ├── icon16.png        # 扩展图标(16x16)
    ├── icon48.png        # 扩展图标(48x48)
    └── icon128.png       # 扩展图标(128x128)
```

## 步骤1：创建扩展配置文件

首先，创建一个名为`summary-extension`的新文件夹，然后在其中创建`manifest.json`文件，这是扩展的配置文件：

```json
{
  "manifest_version": 3,
  "name": "网页内容摘要",
  "version": "1.0",
  "description": "生成当前网页内容的简明摘要",
  "icons": {
    "16": "images/icon16.png",
    "48": "images/icon48.png",
    "128": "images/icon128.png"
  },
  "action": {
    "default_popup": "popup/popup.html",
    "default_icon": {
      "16": "images/icon16.png",
      "48": "images/icon48.png",
      "128": "images/icon128.png"
    }
  },
  "permissions": ["activeTab", "scripting"],
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["scripts/content.js"]
    }
  ]
}
```

这个配置文件定义了扩展的基本信息、权限和行为。`permissions`字段中的`activeTab`和`scripting`权限允许扩展访问当前标签页并执行脚本。

## 步骤2：创建扩展图标

在项目文件夹中创建`images`目录，用于存放扩展的图标。你需要创建三种尺寸的图标：

- `icon16.png` (16x16像素)
- `icon48.png` (48x48像素)
- `icon128.png` (128x128像素)

你可以使用任何图像编辑工具创建这些图标，或者在网上找到合适的免费图标并调整其尺寸。对于本教程，你可以使用一个简单的摘要或文档图标。

## 步骤3：创建弹出窗口界面

在项目文件夹中创建`popup`目录，然后创建以下文件：

### popup.html
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>网页内容摘要</title>
  <link rel="stylesheet" href="popup.css">
</head>
<body>
  <div class="container">
    <h1>网页内容摘要</h1>
    
    <div class="status-container">
      <div id="loading" class="loading hidden">
        <div class="spinner"></div>
        <p>正在生成摘要...</p>
      </div>
      
      <div id="error-message" class="error hidden">
        无法生成摘要，请在包含足够文本内容的页面上尝试。
      </div>
    </div>
    
    <div id="results" class="results hidden">
      <div class="summary-section">
        <h2>页面标题</h2>
        <p id="page-title"></p>
      </div>
      
      <div class="summary-section">
        <h2>主要内容</h2>
        <p id="main-content"></p>
      </div>
      
      <div class="summary-section">
        <h2>关键点</h2>
        <ul id="key-points"></ul>
      </div>
      
      <div class="actions">
        <button id="copy-btn">复制摘要</button>
      </div>
    </div>
    
    <div class="footer">
      <button id="generate-btn">生成摘要</button>
    </div>
  </div>
  
  <script src="popup.js"></script>
</body>
</html>
```

### popup.css
```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #f9f9f9;
  color: #333;
  min-width: 300px;
  max-width: 350px;
}

.container {
  padding: 15px;
}

h1 {
  font-size: 1.3rem;
  color: #2c3e50;
  text-align: center;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 1px solid #e0e0e0;
}

h2 {
  font-size: 1rem;
  color: #3498db;
  margin-bottom: 8px;
}

.status-container {
  min-height: 60px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 20px 0;
}

.spinner {
  width: 30px;
  height: 30px;
  border: 3px solid #f3f3f3;
  border-top: 3px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 10px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.error {
  color: #e74c3c;
  text-align: center;
  padding: 10px;
  background-color: #fceaea;
  border-radius: 5px;
  margin: 15px 0;
}

.summary-section {
  margin-bottom: 15px;
}

#page-title {
  font-weight: bold;
}

#key-points {
  margin-left: 20px;
}

#key-points li {
  margin-bottom: 5px;
}

.actions {
  margin-top: 15px;
  text-align: right;
}

button {
  background-color: #3498db;
  color: white;
  border: none;
  padding: 8px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.3s;
}

button:hover {
  background-color: #2980b9;
}

#copy-btn {
  background-color: #2ecc71;
}

#copy-btn:hover {
  background-color: #27ae60;
}

.footer {
  margin-top: 15px;
  text-align: center;
}

.hidden {
  display: none;
}
```

## 步骤4：实现内容脚本和摘要生成逻辑

在项目文件夹中创建`scripts`目录，然后创建以下文件：

### content.js
```javascript
// 这个脚本将注入到网页中，用于获取页面内容

// 监听来自弹出窗口的消息
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === 'getSummary') {
    // 提取页面内容并生成摘要
    const summary = extractPageContent();
    
    // 将结果发送回弹出窗口
    sendResponse(summary);
  }
  
  // 必须返回true，表示我们将异步发送响应
  return true;
});

// 提取页面内容的函数
function extractPageContent() {
  try {
    // 获取页面标题
    const pageTitle = document.title;
    
    // 获取正文内容
    let mainContent = '';
    
    // 尝试提取文章主要内容
    // 首先尝试查找常见的内容容器
    const contentSelectors = [
      'article', 'main', '.content', '.article', '.post', 
      '#content', '#main', '.main-content', '.article-content'
    ];
    
    let contentElement = null;
    
    for (const selector of contentSelectors) {
      const element = document.querySelector(selector);
      if (element) {
        contentElement = element;
        break;
      }
    }
    
    // 如果没有找到特定内容容器，就尝试获取所有段落
    if (!contentElement) {
      contentElement = document.body;
    }
    
    // 获取页面中的所有段落
    const paragraphs = contentElement.querySelectorAll('p');
    
    // 过滤掉太短的段落并连接剩余段落
    const significantParagraphs = Array.from(paragraphs)
      .filter(p => p.textContent.trim().length > 50)
      .map(p => p.textContent.trim());
    
    // 将文本连接起来，最多取前5个段落
    mainContent = significantParagraphs.slice(0, 5).join('\n\n');
    
    // 如果没有找到有意义的段落，尝试获取所有文本内容
    if (!mainContent) {
      mainContent = contentElement.textContent.trim()
        .replace(/\s+/g, ' ')
        .substring(0, 1000);
    }
    
    // 提取关键点
    const keyPoints = extractKeyPoints(contentElement);
    
    // 返回摘要对象
    return {
      success: true,
      pageTitle: pageTitle,
      mainContent: summarizeText(mainContent, 250),
      keyPoints: keyPoints
    };
  } catch (error) {
    // 出错时返回错误信息
    console.error('提取内容时出错:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

// 提取关键点
function extractKeyPoints(element) {
  // 尝试从列表项中提取
  const listItems = element.querySelectorAll('ul > li, ol > li');
  let keyPoints = [];
  
  if (listItems.length > 0) {
    // 从列表项中提取文本
    keyPoints = Array.from(listItems)
      .filter(li => li.textContent.trim().length > 15 && li.textContent.trim().length < 200)
      .map(li => li.textContent.trim())
      .slice(0, 5); // 最多取5个关键点
  }
  
  // 如果没有找到合适的列表项，尝试从标题和加粗文本中提取
  if (keyPoints.length === 0) {
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6, strong, b');
    keyPoints = Array.from(headings)
      .filter(h => h.textContent.trim().length > 15 && h.textContent.trim().length < 200)
      .map(h => h.textContent.trim())
      .slice(0, 5); // 最多取5个关键点
  }
  
  // 如果依然没有关键点，尝试从段落中提取短句
  if (keyPoints.length === 0) {
    const paragraphs = element.querySelectorAll('p');
    const sentences = [];
    
    paragraphs.forEach(p => {
      const text = p.textContent.trim();
      const parts = text.split(/[.!?。？！]/); // 按句子分割
      
      parts.forEach(part => {
        const trimmed = part.trim();
        if (trimmed.length > 20 && trimmed.length < 150) {
          sentences.push(trimmed);
        }
      });
    });
    
    keyPoints = sentences.slice(0, 5); // 最多取5个句子作为关键点
  }
  
  return keyPoints;
}

// 简单的文本摘要函数
function summarizeText(text, maxLength) {
  if (text.length <= maxLength) {
    return text;
  }
  
  // 简单地截断文本并添加省略号
  const truncated = text.substring(0, maxLength).trim();
  
  // 尝试在句子结束处截断
  const lastPeriod = Math.max(
    truncated.lastIndexOf('.'),
    truncated.lastIndexOf('!'),
    truncated.lastIndexOf('?'),
    truncated.lastIndexOf('。'),
    truncated.lastIndexOf('！'),
    truncated.lastIndexOf('？')
  );
  
  if (lastPeriod > maxLength * 0.7) {
    return truncated.substring(0, lastPeriod + 1);
  }
  
  return truncated + '...';
}
```

### summarizer.js (可选的额外功能)
```javascript
// 更高级的文本摘要算法可以在这里实现
// 这个文件是可选的，如果你想尝试更复杂的摘要算法

// 基于TF-IDF的简单摘要算法
function advancedSummarize(text, sentenceCount = 3) {
  // 将文本分割成句子
  const sentences = text.split(/[.!?。！？]/g)
    .map(s => s.trim())
    .filter(s => s.length > 10);
  
  // 如果句子数太少，直接返回原文
  if (sentences.length <= sentenceCount) {
    return sentences.join(". ");
  }
  
  // 计算每个单词的频率
  const wordFrequency = {};
  const stopWords = new Set(["的", "了", "是", "在", "和", "有", "上", "与", "就", "而", "也", "为", "这", "他", "那", "a", "an", "the", "in", "on", "to", "for", "with", "by", "at", "of", "and", "or", "but"]);
  
  sentences.forEach(sentence => {
    // 将句子分割成单词
    const words = sentence.toLowerCase()
      .split(/\s+|[,.;:"'?!，。；：""'？！]/g)
      .filter(word => word.length > 1 && !stopWords.has(word));
    
    // 更新词频统计
    words.forEach(word => {
      wordFrequency[word] = (wordFrequency[word] || 0) + 1;
    });
  });
  
  // 计算每个句子的分数（基于包含高频词的数量）
  const sentenceScores = sentences.map(sentence => {
    const words = sentence.toLowerCase()
      .split(/\s+|[,.;:"'?!，。；：""'？！]/g)
      .filter(word => word.length > 1 && !stopWords.has(word));
    
    let score = 0;
    words.forEach(word => {
      if (wordFrequency[word]) {
        score += wordFrequency[word];
      }
    });
    
    // 归一化分数，使短句子不会受到惩罚
    return score / Math.max(1, words.length);
  });
  
  // 找出得分最高的几个句子的索引
  const topIndices = [];
  for (let i = 0; i < sentenceCount; i++) {
    let maxScore = -1;
    let maxIndex = -1;
    
    sentenceScores.forEach((score, index) => {
      if (score > maxScore && !topIndices.includes(index)) {
        maxScore = score;
        maxIndex = index;
      }
    });
    
    if (maxIndex !== -1) {
      topIndices.push(maxIndex);
    }
  }
  
  // 按原始顺序排序这些句子
  topIndices.sort();
  
  // 返回摘要
  return topIndices.map(index => sentences[index]).join(". ");
}
```

## 步骤5：实现弹出窗口脚本

现在让我们创建弹出窗口的JavaScript文件：

### popup.js
```javascript
// DOM元素
const loadingElement = document.getElementById('loading');
const errorElement = document.getElementById('error-message');
const resultsElement = document.getElementById('results');
const pageTitleElement = document.getElementById('page-title');
const mainContentElement = document.getElementById('main-content');
const keyPointsElement = document.getElementById('key-points');
const generateButton = document.getElementById('generate-btn');
const copyButton = document.getElementById('copy-btn');

// 当用户点击"生成摘要"按钮时
generateButton.addEventListener('click', async () => {
  // 显示加载状态
  showLoading();
  
  try {
    // 获取当前标签页
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    
    // 发送消息到内容脚本
    chrome.tabs.sendMessage(tab.id, { action: 'getSummary' }, (response) => {
      // 处理错误
      if (chrome.runtime.lastError) {
        showError(`无法与页面通信: ${chrome.runtime.lastError.message}`);
        return;
      }
      
      // 处理响应
      if (response && response.success) {
        displayResults(response);
      } else {
        showError(response?.error || '无法生成摘要，请在另一个页面上尝试。');
      }
    });
  } catch (error) {
    showError(`发生错误: ${error.message}`);
  }
});

// 当用户点击"复制摘要"按钮时
copyButton.addEventListener('click', () => {
  // 构建要复制的文本
  const title = pageTitleElement.textContent;
  const mainContent = mainContentElement.textContent;
  const keyPoints = Array.from(keyPointsElement.querySelectorAll('li'))
    .map(li => `• ${li.textContent}`)
    .join('\n');
  
  const textToCopy = `标题: ${title}\n\n主要内容:\n${mainContent}\n\n关键点:\n${keyPoints}`;
  
  // 复制到剪贴板
  navigator.clipboard.writeText(textToCopy)
    .then(() => {
      // 临时改变按钮文本以提供反馈
      const originalText = copyButton.textContent;
      copyButton.textContent = '已复制!';
      
      setTimeout(() => {
        copyButton.textContent = originalText;
      }, 1500);
    })
    .catch(err => {
      console.error('复制到剪贴板失败:', err);
    });
});

// 显示加载状态
function showLoading() {
  loadingElement.classList.remove('hidden');
  errorElement.classList.add('hidden');
  resultsElement.classList.add('hidden');
}

// 显示错误信息
function showError(message) {
  loadingElement.classList.add('hidden');
  errorElement.classList.remove('hidden');
  resultsElement.classList.add('hidden');
  
  errorElement.textContent = message;
}

// 显示摘要结果
function displayResults(summary) {
  loadingElement.classList.add('hidden');
  errorElement.classList.add('hidden');
  resultsElement.classList.remove('hidden');
  
  // 填充内容
  pageTitleElement.textContent = summary.pageTitle;
  mainContentElement.textContent = summary.mainContent;
  
  // 填充关键点
  keyPointsElement.innerHTML = '';
  if (summary.keyPoints && summary.keyPoints.length > 0) {
    summary.keyPoints.forEach(point => {
      const li = document.createElement('li');
      li.textContent = point;
      keyPointsElement.appendChild(li);
    });
  } else {
    const li = document.createElement('li');
    li.textContent = '未找到关键点';
    keyPointsElement.appendChild(li);
  }
}

// 页面加载时自动生成摘要
document.addEventListener('DOMContentLoaded', () => {
  generateButton.click();
});
```

## 步骤6：安装和测试扩展

现在我们的浏览器扩展已经完成，让我们安装并测试它：

1. 打开Chrome浏览器
2. 访问`chrome://extensions/`
3. 启用右上角的"开发者模式"
4. 点击"加载已解压的扩展程序"按钮
5. 选择你的`summary-extension`文件夹

扩展现在已经安装完成。你应该能在Chrome工具栏中看到扩展图标。

要测试扩展：

1. 访问任何包含大量文本的网页（如新闻文章、博客或维基百科）
2. 点击扩展图标，弹出窗口应该会出现
3. 如果没有自动生成摘要，点击"生成摘要"按钮
4. 查看生成的页面标题、主要内容和提取的关键点
5. 使用"复制摘要"按钮测试复制功能

## 步骤7：优化与改进

现在我们有了一个基本的工作版本，可以考虑一些优化和改进：

### 改进文本分析算法

对于更高级的摘要功能，可以考虑：

1. 使用NLP库进行更准确的句子分割
2. 实现更复杂的关键词提取算法
3. 添加主题分类功能

要使用NLP库，你需要修改清单文件，添加额外的依赖项。这超出了本教程的范围，但对于进一步的学习可能是有益的。

### 添加更多功能

考虑添加以下功能来增强扩展：

1. **可定制设置**：允许用户调整摘要长度或关键点数量
2. **历史记录**：保存之前生成的摘要
3. **分享功能**：添加直接分享摘要到社交媒体或邮件的功能
4. **保存为PDF**：添加将摘要保存为PDF文件的选项

## 步骤8：发布扩展（可选）

如果你对扩展感到满意，可以考虑将其发布到Chrome网上应用店：

1. 创建一个Chrome开发者账户（需要支付一次性注册费）
2. 准备高质量的图标和截图
3. 编写详细的描述和隐私政策
4. 打包扩展文件并上传到Chrome开发者控制台

这一步是可选的，但如果你想与更多用户分享你的创作，这是一个很好的方式。

## 总结

恭喜！你已经成功创建了一个Chrome浏览器扩展，它可以分析网页内容并生成摘要。通过这个项目，你学习了：

- 如何创建和配置Chrome浏览器扩展
- 如何使用内容脚本与网页交互
- 如何提取和处理网页内容
- 如何实现简单的文本分析和摘要生成
- 如何创建交互式的扩展弹出界面

这个项目是浏览器扩展开发的良好起点，它结合了前端开发技能和实用的功能，为你提供了实践经验。

## 常见问题解答

**Q: 为什么有些网页无法生成摘要？**  
A: 某些网页可能使用复杂的JavaScript渲染内容，或者有特殊的内容结构，使得我们的简单提取算法无法正常工作。你可以尝试改进内容脚本以处理更多的情况。

**Q: 如何提高摘要质量？**  
A: 考虑使用更复杂的自然语言处理技术，例如句子重要性排名或命名实体识别。也可以考虑使用外部API如OpenAI API来生成更智能的摘要。

**Q: 我的扩展为什么不能在所有网站上工作？**  
A: 某些网站可能禁止内容脚本运行，或者使用的技术与我们的代码不兼容。尝试在`manifest.json`中调整权限或内容脚本的匹配规则。

**Q: 如何让扩展在Chrome以外的浏览器上工作？**  
A: 许多现代浏览器（如Firefox、Edge、Opera）都支持Chrome扩展或者需要做很小的修改。查阅各浏览器的扩展开发文档来了解具体差异。

**下一步学习**：尝试构建一个[专注时钟应用](/docs/projects/beginners/focus-timer)，学习如何创建定时器和通知功能！ 